<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Triangle Calculator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: black;
            color: white;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            margin: 0;
            padding: 20px;
        }
        .controls, .results {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 20px;
        }
        label {
            display: flex;
            flex-direction: column;
        }
        input {
            margin-top: 5px;
            padding: 5px;
            color: white;
            background-color: black;
            border: 1px solid white;
            text-align: center;
            max-width: 100px;
        }
        input[readonly] {
            background-color: grey;
            border-color: grey;
        }
        canvas {
            border: 1px solid white;
            background-color: black;
            margin-left: 20px;
        }
        button {
            margin-top: 10px;
            padding: 10px;
            font-size: 1em;
            background-color: white;
            color: black;
            border: none;
            cursor: pointer;
        }
        .status {
            margin-top: 20px;
            font-size: 1.2em;
        }
        .results input {
            width: 100%;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="controls">
        <label>Input Angle A: 
            <input type="number" id="inputAngleA" min="0" max="179">
        </label>
        <label>Input Angle B: 
            <input type="number" id="inputAngleB" min="0" max="179">
        </label>
        <label>Input Angle C: 
            <input type="number" id="inputAngleC" min="0" max="179">
        </label>
        <label>Input Side a: 
            <input type="number" id="inputSideA" min="0">
        </label>
        <label>Input Side b: 
            <input type="number" id="inputSideB" min="0">
        </label>
        <label>Input Side c: 
            <input type="number" id="inputSideC" min="0">
        </label>
        <button onclick="resetInputs()">Reset</button>
        <button id="newLayerButton" onclick="addNewLayer()" disabled>New Layer</button>
    </div>

    <canvas id="triangleCanvas" width="500" height="500"></canvas>
    
    <div class="results">

        <label>Angle A: <input type="text" id="angleA" readonly></label>
        <label>Angle B: <input type="text" id="angleB" readonly></label>
        <label>Angle C: <input type="text" id="angleC" readonly></label>
        <label>Side a: <input type="text" id="sideA" readonly></label>
        <label>Side b: <input type="text" id="sideB" readonly></label>
        <label>Side c: <input type="text" id="sideC" readonly></label>
        <label>Perimeter: <input type="text" id="perimeter" readonly></label>
        <label>Area: <input type="text" id="area" readonly></label>
    </div>

    <script>
        const canvas = document.getElementById('triangleCanvas');
        const ctx = canvas.getContext('2d');
        const maxDimension = 500;
        let maxValue = 1;

        let p1 = null;
        let p2 = null;
        let p3 = null;
        let draggingPoint = null;
        const inputsOrder = [];
        let layers = []; // Stores the triangles added as layers

// Add event listeners for desktop (mouse) and mobile (touch) dragging
canvas.addEventListener('mousedown', handleStartDrag);
canvas.addEventListener('mousemove', handleMoveDrag);
canvas.addEventListener('mouseup', handleEndDrag);

// Touch events for mobile support
canvas.addEventListener('touchstart', handleStartDrag);
canvas.addEventListener('touchmove', handleMoveDrag);
canvas.addEventListener('touchend', handleEndDrag);


// Function to start dragging (either mouse or touch)
function handleStartDrag(event) {
    const { x, y } = getEventPosition(event);
    console.log("Start Dragging at:", x, y); // Debug log

    if (isNearPoint(x, y, p1)) {
        draggingPoint = p1;
        console.log("Dragging point A");
    } else if (isNearPoint(x, y, p2)) {
        draggingPoint = p2;
        console.log("Dragging point B");
    } else if (isNearPoint(x, y, p3)) {
        draggingPoint = p3;
        console.log("Dragging point C");
    }

    event.preventDefault(); // Prevent default behavior (important for touch events)
}

// Function to handle dragging movement (either mouse or touch)
function handleMoveDrag(event) {
    if (!draggingPoint) return; // If no point is selected, return

    const { x, y } = getEventPosition(event);
    console.log("Moving to:", x, y); // Debug log

    // Update the position of the dragging point
    draggingPoint.x = x;
    draggingPoint.y = y;

    // Recalculate and redraw the triangle based on the new point position
    calculateFromCanvas(); // This function needs to recalculate the triangle's sides/angles
    drawTriangle(); // Redraw the updated triangle

    event.preventDefault(); // Prevent default behavior (important for touch events)
}

// Function to stop dragging (either mouse or touch)
function handleEndDrag(event) {
    console.log("End dragging"); // Debug log
    draggingPoint = null; // Reset the dragged point
    event.preventDefault(); // Prevent default behavior
}

// Helper function to normalize event positions (works for both mouse and touch)
function getEventPosition(event) {
    const rect = canvas.getBoundingClientRect();
    let x, y;

    if (event.touches) {
        // Touch event
        x = event.touches[0].clientX - rect.left;
        y = event.touches[0].clientY - rect.top;
    } else {
        // Mouse event
        x = event.clientX - rect.left;
        y = event.clientY - rect.top;
    }

    console.log("Normalized Event Position:", x, y); // Debug log
    return { x, y };
}

// Helper function to check if the event is near a point
function isNearPoint(x, y, point) {
    const dx = x - point.x;
    const dy = y - point.y;
    const distanceSquared = dx * dx + dy * dy;
    const threshold = 100000; // Sensitivity threshold

    const isNear = distanceSquared <= threshold;
    console.log(`Is near point (${point.x}, ${point.y})?`, isNear); // Debug log
    return isNear;
}



     function drawTriangle() {
    // Clear the entire canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw the stored red triangles first (layers)
    drawAllLayers(); // This function will draw any stored layers

    // Now draw the current triangle in white if it exists
    if (p1 && p2 && p3) {
        ctx.strokeStyle = 'white'; // Set the color for the new triangle
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.lineTo(p3.x, p3.y);
        ctx.closePath();
        ctx.stroke();

        drawPoint(p1, 'A');
        drawPoint(p2, 'B');
        drawPoint(p3, 'C');
    }
}

        function drawPoint(point, label) {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2, true);
            ctx.fillStyle = 'red';
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = 'white';
            ctx.fillText(label, point.x + 5, point.y - 5);
        }

function addNewLayer() {
    if (p1 && p2 && p3) {
        // Save current triangle points as a layer
        layers.push({ p1: { ...p1 }, p2: { ...p2 }, p3: { ...p3 } });
        console.log("New layer added:", layers); // Debugging log to check if layers are added correctly
    }

    // Clear input/output boxes but retain the current canvas
    resetInputs(true); // Keep the canvas and layers intact

    // Disable the "New Layer" button until new inputs are added
    document.getElementById('newLayerButton').disabled = true;

    // Redraw layers and the current canvas state
    drawTriangle(); // This will call drawAllLayers() and keep the layers visible
}

function resetInputs(keepLayers = false) {
    const inputIds = ['inputSideA', 'inputSideB', 'inputSideC', 'inputAngleA', 'inputAngleB', 'inputAngleC'];
    inputIds.forEach(id => document.getElementById(id).value = '');
    const outputIds = ['sideA', 'sideB', 'sideC', 'angleA', 'angleB', 'angleC', 'perimeter', 'area'];
    outputIds.forEach(id => document.getElementById(id).value = '');

    // Clear the canvas and layers if not keeping layers
    if (!keepLayers) {
        console.log("Clearing canvas and resetting layers"); // Debugging log
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        layers = []; // Clear all stored triangle layers from memory
        console.log("Layers after reset:", layers); // Debugging log
    }

    // Reset the triangle points
    p1 = p2 = p3 = null;
    inputsOrder.length = 0;

    // Redraw all layers if they exist and are kept
    if (keepLayers) {
        drawAllLayers();
    }
}

function drawAllLayers() {
    if (layers.length > 0) {
        ctx.strokeStyle = 'red'; // Set color for red triangles
        layers.forEach(layer => {
            ctx.beginPath();
            ctx.moveTo(layer.p1.x, layer.p1.y);
            ctx.lineTo(layer.p2.x, layer.p2.y);
            ctx.lineTo(layer.p3.x, layer.p3.y);
            ctx.closePath();
            ctx.stroke();
        });
    }
}

        function calculateAndDraw(lastChangedInput) {
            const sideA = parseFloat(document.getElementById('inputSideA').value) || 0;
            const sideB = parseFloat(document.getElementById('inputSideB').value) || 0;
            const sideC = parseFloat(document.getElementById('inputSideC').value) || 0;
            const angleA = parseFloat(document.getElementById('inputAngleA').value) || 0;
            const angleB = parseFloat(document.getElementById('inputAngleB').value) || 0;
            const angleC = parseFloat(document.getElementById('inputAngleC').value) || 0;

            const sides = [sideA, sideB, sideC].filter(v => v > 0).length;
            const angles = [angleA, angleB, angleC].filter(v => v > 0).length;

            if (sides + angles !== 3) return;

            let a = sideA;
            let b = sideB;
            let c = sideC;
            let A = angleA * (Math.PI / 180);
            let B = angleB * (Math.PI / 180);
            let C = angleC * (Math.PI / 180);
    

    // 4. If angles A, B, and side a are given, calculate sides b and c
    if (A && B && a && !b && !c && !C) {
        C = Math.PI - A - B;
        c = a * Math.sin(C) / Math.sin(A);
        b = a * Math.sin(B) / Math.sin(A);
    }

    // 5. If angles A, B, and side b are given, calculate sides a and c
    if (A && B && b && !a && !c && !C) {
        C = Math.PI - A - B;
        a = b * Math.sin(A) / Math.sin(B);
        c = b * Math.sin(C) / Math.sin(B);
    }

    // 6. If angles A, B, and side c are given, calculate sides a and b
    if (A && B && c && !a && !b && !C) {
        C = Math.PI - A - B;
        a = c * Math.sin(A) / Math.sin(C);
        b = c * Math.sin(B) / Math.sin(C);
    }

    // 7. If angles A, C, and side a are given, calculate sides b and c
    if (A && C && a && !b && !c && !B) {
        B = Math.PI - A - C;
        b = a * Math.sin(B) / Math.sin(A);
        c = a * Math.sin(C) / Math.sin(A);
    }

    // 8. If angles A, C, and side b are given, calculate sides a and c
    if (A && C && b && !a && !c && !B) {
        B = Math.PI - A - C;
        a = b * Math.sin(A) / Math.sin(B);
        c = b * Math.sin(C) / Math.sin(B);
    }

    // 9. If angles A, C, and side c are given, calculate sides a and b
    if (A && C && c && !a && !b && !B) {
        B = Math.PI - A - C;
        a = c * Math.sin(A) / Math.sin(C);
        b = c * Math.sin(B) / Math.sin(C);
    }

    // 10. If angles B, C, and side a are given, calculate sides b and c
    if (B && C && a && !b && !c && !A) {
        A = Math.PI - B - C;
        b = a * Math.sin(B) / Math.sin(A);
        c = a * Math.sin(C) / Math.sin(A);
    }

    // 11. If angles B, C, and side b are given, calculate sides a and c
    if (B && C && b && !a && !c && !A) {
        A = Math.PI - B - C;
        a = b * Math.sin(A) / Math.sin(B);
        c = b * Math.sin(C) / Math.sin(B);
    }

    // 12. If angles B, C, and side c are given, calculate sides a and b
    if (B && C && c && !a && !b && !A) {
        A = Math.PI - B - C;
        a = c * Math.sin(A) / Math.sin(C);
        b = c * Math.sin(B) / Math.sin(C);
    }

    // 13. If sides a, b, and angle A are given, calculate side c and angles B, C
    if (a && b && A && !c && !B && !C) {
        c = Math.abs(b * Math.cos(A) + Math.sqrt(a * a - b * b * Math.sin(A) * Math.sin(A)));
        C = Math.abs(Math.acos((a * a + b * b - c * c) / (2 * a * b)));
        B = Math.PI - C - A;
       
    }

    // 14. If sides a, b, and angle B are given, calculate side c and angles A, C
    if (a && b && B && !c && !A && !C) {
        c = Math.abs(a * Math.cos(B) + Math.sqrt(b * b - a * a * Math.sin(B) * Math.sin(B)));
        C = Math.abs(Math.acos((a * a + b * b - c * c) / (2 * a * b)));
        A = Math.PI - B - C;
        
    }

    // 15. If sides a, b, and angle C are given, calculate side c and angles A, B
    if (a && b && C && !c && !A && !B) {
        c = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(C));
        A = Math.abs(Math.acos((b * b + c * c - a * a) / (2 * b * c)));
        B = Math.PI - C - A;
     
    }

    // 16. If sides a, c, and angle A are given, calculate side b and angles B, C
    if (a && c && A && !b && !B && !C) {
        b = Math.abs(c * Math.cos(A) + Math.sqrt(a * a - c * c * Math.sin(A) * Math.sin(A)));
        B = Math.abs(Math.acos((a * a + c * c - b * b) / (2 * a * c)));
        C = Math.PI - B - A;
       
    }

    // 17. If sides a, c, and angle B are given, calculate side b and angles A, C
    if (a && c && B && !b && !A && !C) {
        b = Math.sqrt(a * a + c * c - 2 * a * c * Math.cos(B));
        A = Math.abs(Math.acos((b * b + c * c - a * a) / (2 * b * c)));
        C = Math.PI - B - A;
       
    }

    // 18. If sides a, c, and angle C are given, calculate side b and angles A, B
    if (a && c && C && !b && !A && !B) {
        b = Math.abs(a * Math.cos(C) + Math.sqrt(c * c - a * a * Math.sin(C) * Math.sin(C)));
        A = Math.abs(Math.acos((b * b + c * c - a * a) / (2 * b * c)));
        B = Math.PI - C - A;
       
    }

    // 19. If sides b, c, and angle A are given, calculate side a and angles B, C
    if (b && c && A && !a && !B && !C) {
        a = Math.sqrt(b * b + c * c - 2 * b * c * Math.cos(A));
        B = Math.abs(Math.acos((a * a + c * c - b * b) / (2 * a * c)));
        C = Math.PI - B - A;
        
    }

    // 20. If sides b, c, and angle B are given, calculate side a and angles A, C
    if (b && c && B && !a && !A && !C) {
        a = Math.abs(c * Math.cos(B) + Math.sqrt(b * b - c * c * Math.sin(B) * Math.sin(B)));
        A = Math.abs(Math.acos((b * b + c * c - a * a) / (2 * b * c)));
        C = Math.PI - B - A;
        
    }

    // 21. If sides b, c, and angle C are given, calculate side a and angles A, B
    if (b && c && C && !a && !A && !B) {
        a = Math.abs(b * Math.cos(C) + Math.sqrt(c * c - b * b * Math.sin(C) * Math.sin(C)));
        A = Math.abs(Math.acos((b * b + c * c - a * a) / (2 * b * c)));
        B = Math.PI - C - A;
       
    }

    // 22. If sides a, b, and c are given, calculate angles A, B, C
    if (a && b && c && !A && !B && !C) {
        A = Math.acos((b * b + c * c - a * a) / (2 * b * c));
        B = Math.acos((a * a + c * c - b * b) / (2 * a * c));
        C = Math.PI - A - B;
    }

    // 23. If angles A, B, and C are given, calculate sides a, b, c
    if (A && B && C && !a && !b && !c) {
        a = 10;
        b = a * Math.sin(B) / Math.sin(A);
        c = a * Math.sin(C) / Math.sin(A);


    

   
}
            

          

           A *= 180 / Math.PI;
           B *= 180 / Math.PI;
           C *= 180 / Math.PI;



            document.getElementById('sideA').value = a.toFixed(2);
            document.getElementById('sideB').value = b.toFixed(2);
            document.getElementById('sideC').value = c.toFixed(2);
            document.getElementById('angleA').value = A.toFixed(2);
            document.getElementById('angleB').value = B.toFixed(2);
            document.getElementById('angleC').value = C.toFixed(2);

           let hasNaN = false;
           
            setTimeout(() => {
            console.log('Checking for NaN after timeout...');

            checkForNaNValues();
        }, 15);
           

          console.log('NaN check completed.');

        // Continue with drawing the triangle if no NaN detected

if (!hasNaN) {
        
            maxValue = Math.max(a, b, c);
            const perimeter = a + b + c;
            const s = perimeter / 2;
            const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));

            document.getElementById('perimeter').value = perimeter.toFixed(2);
            document.getElementById('area').value = area.toFixed(2);

            calculateAndPositionTriangle(a, b, c, A, B, C);

            

           drawTriangle();
           drawPoint(p1, 'A');
           drawPoint(p2, 'B');
           drawPoint(p3, 'C');
        }
}
        

function handleInput(event) {
    const inputId = event.target.id;
    const inputValue = document.getElementById(inputId).value;

    // 1. Check if an angle is greater than 179
    if (inputId.startsWith('inputAngle') && inputValue > 179) {
        alert('Angle cannot be greater than 179 degrees.');
        document.getElementById(inputId).value = '';
        return;
    }

    // 2. Check if the sum of angles exceeds 180
    if (inputId.startsWith('inputAngle')) {
        const angleA = parseFloat(document.getElementById('inputAngleA').value) || 0;
        const angleB = parseFloat(document.getElementById('inputAngleB').value) || 0;
        const angleC = parseFloat(document.getElementById('inputAngleC').value) || 0;

        const angleSum = angleA + angleB + angleC;
        console.log('Sum of angles:', angleSum); // Add this line to debug the angle sum

        if (angleSum !== 180 && angleA !== 0 && angleB !== 0 && angleC !== 0) {
            alert('The sum of angles must equal 180 degrees.');
           document.getElementById(inputId).value = '';
            return;
        }
    }

    // 3. Check if the triangle inequality is violated
    if (inputId.startsWith('inputSide')) {
        const sideA = parseFloat(document.getElementById('inputSideA').value) || 0;
        const sideB = parseFloat(document.getElementById('inputSideB').value) || 0;
        const sideC = parseFloat(document.getElementById('inputSideC').value) || 0;

        if (sideA > 0 && sideB > 0 && sideC > 0) {
            if (!(sideA + sideB > sideC && sideA + sideC > sideB && sideB + sideC > sideA)) {
                alert('The side lengths do not satisfy the triangle inequality.');
                document.getElementById(inputId).value = '';
                return;
            }
        }
    }

    // 4. Manage input order (ensure exactly 3 inputs are processed)
    if (inputValue === '' || parseFloat(inputValue) === 0) {
        const index = inputsOrder.indexOf(inputId);
        if (index > -1) {
            inputsOrder.splice(index, 1);
        }
    } else {
        if (!inputsOrder.includes(inputId)) {
            if (inputsOrder.length === 3) {
                const oldestInput = inputsOrder.shift();
                document.getElementById(oldestInput).value = '';
            }
            inputsOrder.push(inputId);
        }
    }

       // 5. Only proceed if exactly 3 inputs have been entered
    if (inputsOrder.length === 3) {
        // Attempt to calculate and draw the triangle
        calculateAndDraw(inputId);

        
    }

  // Enable the "New Layer" button when exactly 3 inputs are entered
    if (inputsOrder.length === 3) {
        calculateAndDraw(inputId);
        document.getElementById('newLayerButton').disabled = false;
        console.log('New Layer button enabled');
        // Enable New Layer button
    } else {
        document.getElementById('newLayerButton').disabled = true;
       console.log('New Layer button disabled'); 
       // Disable New Layer button if conditions are not met
    }
}

function checkForNaNValues() {
    // Retrieve and check each output field individually for NaN
    let sideAc = parseFloat(document.getElementById('sideA').value);
    let sideBc = parseFloat(document.getElementById('sideB').value);
    let sideCc = parseFloat(document.getElementById('sideC').value);
    let angleAc = parseFloat(document.getElementById('angleA').value);
    let angleBc = parseFloat(document.getElementById('angleB').value);
    let angleCc = parseFloat(document.getElementById('angleC').value);
    let perimeterc = parseFloat(document.getElementById('perimeter').value);
    let areac = parseFloat(document.getElementById('area').value);

     hasNaN = false;

    // Check each output field for NaN values
    if (isNaN(sideAc)) {
        console.log('Detected NaN in sideA');
        hasNaN = true;
    }
    if (isNaN(sideBc)) {
        console.log('Detected NaN in sideB');
        hasNaN = true;
    }
    if (isNaN(sideCc)) {
        console.log('Detected NaN in sideC');
        hasNaN = true;
    }
    if (isNaN(angleAc)) {
        console.log('Detected NaN in angleA');
        hasNaN = true;
    }
    if (isNaN(angleBc)) {
        console.log('Detected NaN in angleB');
        hasNaN = true;
    }
    if (isNaN(angleCc)) {
        console.log('Detected NaN in angleC');
        hasNaN = true;
    }
    if (isNaN(perimeterc)) {
        console.log('Detected NaN in perimeter');
        hasNaN = true;
    }
    if (isNaN(areac)) {
        console.log('Detected NaN in area');
        hasNaN = true;
    }

    // If any NaN values are found, trigger error handling
    if (hasNaN) {
        clearLastInputAndOutputs();
 
setTimeout(() => {
            alert('Inputs cannot form a triangle'); 
        }, 15);

       
        
    }
}

function clearLastInputAndOutputs() {
    if (inputsOrder.length > 0) {
        const lastInputId = inputsOrder.pop(); // Remove the last input
        document.getElementById(lastInputId).value = ''; // Clear the input
    }

    // Clear the output boxes
    const outputFields = ['sideA', 'sideB', 'sideC', 'angleA', 'angleB', 'angleC', 'perimeter', 'area'];
    outputFields.forEach(field => {
        document.getElementById(field).value = ''; // Clear output fields
    });

    // Clear the canvas (triangle graph)
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    p1 = p2 = p3 = null; // Reset triangle points
}

function calculateAndPositionTriangle(a, b, c, A, B, C) {
    const padding = 50; // Padding from the canvas edges
    const canvasWidth = maxDimension;
    const canvasHeight = maxDimension;

    // Calculate positions for the triangle based on the input sides and angles
    // Start point for p1 (A) is the bottom-left corner
    p1 = { x: padding, y: canvasHeight - padding };

    // p2 (B) is along the x-axis, at a distance 'c' from p1
    p2 = { x: p1.x + c, y: p1.y };

    // p3 (C) is calculated using trigonometry from p1 and angle A
    const p3x = p1.x + b * Math.cos(A * Math.PI / 180);
    const p3y = p1.y - b * Math.sin(A * Math.PI / 180);
    p3 = { x: p3x, y: p3y };

    // Calculate the bounding box of the triangle
    const xMin = Math.min(p1.x, p2.x, p3.x);
    const xMax = Math.max(p1.x, p2.x, p3.x);
    const yMin = Math.min(p1.y, p2.y, p3.y);
    const yMax = Math.max(p1.y, p2.y, p3.y);

    const triangleWidth = xMax - xMin;
    const triangleHeight = yMax - yMin;

    // Scale the triangle to fit within the canvas dimensions, including padding
    const scaleFactorX = (canvasWidth - 2 * padding) / triangleWidth;
    const scaleFactorY = (canvasHeight - 2 * padding) / triangleHeight;
    const scaleFactor = Math.min(scaleFactorX, scaleFactorY);

    // Apply the scaling to the points
    p1.x = padding + (p1.x - xMin) * scaleFactor;
    p1.y = padding + (p1.y - yMin) * scaleFactor;
    p2.x = padding + (p2.x - xMin) * scaleFactor;
    p2.y = padding + (p2.y - yMin) * scaleFactor;
    p3.x = padding + (p3.x - xMin) * scaleFactor;
    p3.y = padding + (p3.y - yMin) * scaleFactor;
}


        document.querySelectorAll('input[type="number"]').forEach(input => {
            input.addEventListener('blur', handleInput);
            input.addEventListener('keydown', event => {
                if (event.key === 'Enter') handleInput(event);
            });
        });

        canvas.addEventListener('mousedown', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            if (isNearPoint(x, y, p1)) draggingPoint = p1;
            else if (isNearPoint(x, y, p2)) draggingPoint = p2;
            else if (isNearPoint(x, y, p3)) draggingPoint = p3;
        });

        canvas.addEventListener('mousemove', (event) => {
            if (!draggingPoint) return;
            const rect = canvas.getBoundingClientRect();
            draggingPoint.x = event.clientX - rect.left;
            draggingPoint.y = event.clientY - rect.top;
            calculateFromCanvas();
            drawTriangle();
        });

        canvas.addEventListener('mouseup', () => draggingPoint = null);

        function isNearPoint(x, y, point) {
            const dx = x - point.x;
            const dy = y - point.y;
            return dx * dx + dy * dy <= 25;
        }

        function calculateFromCanvas() {

            

              const sideA = (distance(p2, p3) / maxDimension * maxValue) * 1.25; 
              const sideB = (distance(p1, p3) / maxDimension * maxValue) * 1.25; 
              const sideC = (distance(p1, p2) / maxDimension * maxValue) * 1.25; 

              const angleA = Math.acos((sideB ** 2 + sideC ** 2 - sideA ** 2) / (2 * sideB * sideC)) * (180 / Math.PI); 
              const angleB = Math.acos((sideA ** 2 + sideC ** 2 - sideB ** 2) / (2 * sideA * sideC)) * (180 / Math.PI); 
              const angleC = 180 - angleA - angleB; 

            document.getElementById('sideA').value = sideA.toFixed(2);
            document.getElementById('sideB').value = sideB.toFixed(2);
            document.getElementById('sideC').value = sideC.toFixed(2);
            document.getElementById('angleA').value = angleA.toFixed(2);
            document.getElementById('angleB').value = angleB.toFixed(2);
            document.getElementById('angleC').value = angleC.toFixed(2);

            const perimeter = sideA + sideB + sideC;
            const s = perimeter / 2;
            const area = Math.sqrt(s * (s - sideA) * (s - sideB) * (s - sideC));

            document.getElementById('perimeter').value = perimeter.toFixed(2);
            document.getElementById('area').value = area.toFixed(2);

            // Update input values to match output values
            
        if (document.getElementById('inputSideA').value !== '') { 
              document.getElementById('inputSideA').value = sideA.toFixed(2);
            }
        if (document.getElementById('inputSideB').value !== '') {
              document.getElementById('inputSideB').value = sideB.toFixed(2); 
            }
        if (document.getElementById('inputSideC').value !== '') { 
              document.getElementById('inputSideC').value = sideC.toFixed(2); 
            }
        if (document.getElementById('inputAngleA').value !== '') { 
              document.getElementById('inputAngleA').value = angleA.toFixed(2);
            }
        if (document.getElementById('inputAngleB').value !== '') { 
              document.getElementById('inputAngleB').value = angleB.toFixed(2); 
            }
        if (document.getElementById('inputAngleC').value !== '') {
              document.getElementById('inputAngleC').value = angleC.toFixed(2); 
            }


        }

        function distance(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
    </script>
</body>
</html>